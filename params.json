{"name":"Dawdaw","tagline":"A custom saltstack states renderer for extremely lazy python devs","body":"Introduction\r\n============\r\n\r\nDawdaw is an experiment to make a [SaltStack](http://www.saltstack.com/) custom [renderer](http://docs.saltstack.com/en/latest/ref/renderers/index.html) (the stuff that allows you to write your states in yaml/jinja2/mako/other) in an attempt to solve those problems:\r\n\r\n* current states are too verbose to write\r\n* you often repeat yourself too much\r\n* really have a linear states declaration for requires\r\n* explicit requires on included states, to avoid globals\r\n* namespacing all the things, to avoid globals\r\n* indirectly trying to solve the \"salt states are very hard to redistribute\" problem by going full python, you can now use setup.py and pypi/pip to redistribute you workÂ¹\r\n\r\nDisadvantages: you move await from full declarative code (which you were\r\nalready doing in fact with jinja2 templates) to go back to python code. This\r\nis, on one hand very powerful, on the other hand probably too powerful (and may\r\nbe way less easy to understand for devops that don't come from a programming\r\nbackground). That works for me because I'm a python dev and I'm using this for\r\nmy personal usages, but that might not fit your case.\r\n\r\nSample\r\n======\r\n\r\nMove from:\r\n\r\n```yaml\r\ninclude:\r\n  - dotfiles\r\n\r\nwyrd-pkgs:\r\n  pkg.installed:\r\n    - name: wyrd\r\n    - require:\r\n      - sls: dotfiles\r\n\r\nreminds.git:\r\n  git.latest:\r\n    - name: ssh://git@bitbucket.org/psycojoker/reminds.git\r\n    - runas: psycojoker\r\n    - target: /home/psycojoker/reminds/\r\n    - require:\r\n      - pkg: git\r\n\r\ncd /home/psycojoker/reminds/ && bash init:\r\n  cmd.run:\r\n    - unless: ls /home/psycojoker/.reminders /home/psycojoker/.reminders.gcl\r\n    - user: psycojoker\r\n    - require:\r\n      - git: reminds.git\r\n```\r\n\r\nTo:\r\n\r\n```python\r\n#!dawdaw_template\r\n\r\nfrom dawdaw.states import pkg, git, cmd, include\r\nfrom dawdaw.utils import default, test, debug\r\n\r\ndotfiles = include(\"dotfiles\")\r\n\r\nwith default(user=\"psycojoker\", runas=\"psycojoker\"):\r\n    pkg.installed(\"wyrd\",\r\n                  require=[dotfiles.get(\"pkg\", \"dotfiles-pkgs\")])\r\n    git.latest(\"ssh://git@bitbucket.org/psycojoker/reminds.git\",\r\n               target=\"/home/psycojoker/reminds/\")\r\n\r\n    if not test(\"ls /home/psycojoker/.reminders /home/psycojoker/.reminders.gcl\"):\r\n        cmd.run(\"cd /home/psycojoker/reminds/ && bash init\")\r\n```\r\n\r\nInstallation\r\n============\r\n\r\n    pip install dawdaw\r\n\r\n    # this is how you install a renderer in salt\r\n    # if you know a better way to distribute it, plz tell me\r\n\r\n    # adapt the path to the location of your salt data\r\n    mkdir -p /srv/salt/_renderers\r\n    touch /srv/salt/_renderers/__init__.py\r\n\r\n    curl \"https://raw.githubusercontent.com/Psycojoker/dawdaw/master/dawdaw_template.py\" > /srv/salt/_renderers/dawdaw_template.py\r\n\r\n    # if you use salt in master/slave\r\n    salt '*' saltutil.sync_renderers\r\n    # or locally\r\n    salt-call --local saltutil.sync_renderers\r\n\r\nOnce it's done, you can normally run highstates, this will handle\r\ndawdaw_template like any regular other state.\r\n\r\nDocumentation\r\n=============\r\n\r\nOnce you have installed dawdaw (see previous section), to use it, you simply need to put this as the first line of your file (<code>dawdaw_template</code> being the name of the file under which you have redirected the curl command bellow):\r\n\r\n```python\r\n#!dawdaw_template\r\n```\r\n\r\nStates\r\n------\r\n\r\nUsing states is extremely simple: just import the state module and call the\r\ncorresponding function like a python function.\r\n\r\n### Example\r\n\r\n```yaml\r\nstate_name:\r\n  state_module.state_function:\r\n    - argument_1: value_1\r\n    - argument_2: value_2\r\n    - argument_3: value_3\r\n    ...\r\n```\r\n\r\nBecome:\r\n\r\n```python\r\nfrom dawdaw.states import state_module\r\n\r\nstate_module.state_function(\"state_name\",\r\n                            argument_1=\"value_1\",\r\n                            argument_2=\"value_2\",\r\n                            argument_3=\"value_3\",\r\n                            ...)\r\n```\r\n\r\n### Another example\r\n\r\n```yaml\r\nhttps://github.com/Psycojoker/dawdaw:\r\n  git.latest:\r\n    - target: /tmp/dawdaw\r\n```\r\n\r\nBecome:\r\n\r\n```python\r\nfrom dawdaw.states import git\r\n\r\ngit.latest(\"https://github.com/Psycojoker/dawdaw\", target=\"/tmp/dawdaw\")\r\n```\r\n\r\nThe 'default' context manager\r\n-----------------------------\r\n\r\nIn salt, you often end up repeating the same arguments a lot, like settings the\r\nprioprietary of the file to the same user a lot. This is boring and not error proof.\r\nSure, the\r\n'[use](http://docs.saltstack.com/en/latest/ref/states/requisites.html#use)'\r\nexists, but it's awkward and no one knows about it. Thanks to python, we have\r\ncontext managers and we can use the <code>with</code> keyword to handle that.\r\n\r\nThe <code>default</code> context manager create a context in which **every\r\ncommand that waits for some specific keywords will be called with it**.\r\n\r\n### Example\r\n\r\n```python\r\nfrom dawdaw.states import git, file\r\nfrom dawdaw.utils import default\r\n\r\n\r\nwith default(makedirs=True): \r\n    # git won't received the 'makedirs' keyword\r\n    git.latest(\"https:/...\", target=\"/some/stuf\")\r\n\r\n    # file will received it\r\n    file.managed(\"/some/stuff/subdir/settings_prod.py\", source=\"...\")\r\n```\r\n\r\nI often end up using it to settings user and groups:\r\n\r\n```python\r\nwith default(user='psycojoker', group='psycojoker', runas='psycojoker'): \r\n    # ...\r\n```\r\n\r\nModules\r\n-------\r\n\r\n(The stuff you use in the CLI like <code>salt '*' cmd.run \"ls /tmp\"</code>). As simple\r\nas states, just import it and call it like normal python code (and play with\r\nit's return like in normal python):\r\n\r\n```python\r\nfrom dawdaw.modules import cmd\r\n\r\nfor f in cmd.run(\"ls /tmp\"):\r\n    # do some stuff with 'f'\r\n```\r\n\r\nThe 'test' helper\r\n-----------------\r\n\r\nSometime, you need to test if a command return the code '0', you can do it\r\nusing <code>cmd.retcode(\"...\")</code> but that's quite boring. Dawdaw provides\r\na simple helper to do that for you:\r\n\r\n```python\r\nfrom dawdaw.utils import test\r\n\r\nif test(\"ls /tmp/this_file_exist\"):\r\n    # do some stuff\r\n```\r\n\r\nRequisites\r\n----------\r\n\r\nIn dawdaw, you don't have to care that much about requisites, a linear\r\nexecution of the states in the order in which they are called is enforced. This\r\nmean, that, in this example, <code>module.b</code> will have a require on\r\n<code>module.a</code> and <code>module.c</code> will have a require on\r\n<code>module.a</code> **and** <code>module.b</code>:\r\n\r\n```python\r\nmodule.a(\"...\")\r\nmodule.b(\"...\")\r\nmodule.c(\"...\")\r\n```\r\n\r\nThe requires are only set if the state is actually called, so you can use 'if'\r\nand other control flow structure the way you want like in normal python code.\r\n\r\n**If you stil need/want to set explicit requires**, every state return a\r\nreference to itself once it is called, so you can simply do it this way:\r\n\r\n```python\r\na = module.a(\"...\")\r\nmodule.b(\"...\", require=[a])  # remember, requires are set in a list!\r\n```\r\n\r\nNamespacig, watch or more generally: how to refer to a state\r\n------------------------------------------------------------\r\n\r\nIn dawdaw, every state has its name namespaced with the name of the file it is\r\nstored in. For example, this state:\r\n<code>git.latest(\"https://github.com/Psycojoker/dawdaw\")</code> in the file\r\n<code>dawdaw.sls</code> will have the name\r\n<code>dawdaw_https://github.com/Psycojoker/dawdaw</code>. **Keep this in mind\r\nif you want to refer to other states in non-dawdaw states.\r\n\r\nBut when you are in dawdaw you don't have to care about that: every state\r\nreturns a reference to itself once called, you can use that without caring\r\nabout how it is done and without the risk of making stupide mistake or having\r\nto rename it everywhere. For example:\r\n\r\n```python\r\na = module.a(\"...\")\r\nmodule.b(\"...\", watch=[a])  # remember, watchs are set in a list!\r\n```\r\n\r\nWorks for <code>watch</code>, <code>watch_in</code>, <code>require</code>,\r\n<code>require_in</code>, <code>prereq</code>, [the other\r\nrequisites](http://docs.saltstack.com/en/latest/ref/states/requisites.html) etc\r\n... Basically everytime you need to reference a state.\r\n\r\nIf you really need to do that by hand (don't), in reality, the reference is\r\njust a dict, so you can do this this way (don't forget about the namespacing!):\r\n\r\n```python\r\n# in file example.sls\r\n\r\nmodule.a(\"some_name\")\r\nmodule.b(\"...\", watch=[{\"module\": \"example_some_name\"}])  # remember, watchs are set in a list!\r\n```\r\n\r\nBut don't do that.\r\n\r\nInclude\r\n-------\r\n\r\n<code>include</code> works nearly the same than in salt. The only difference is\r\nthat you only include one state at once, not a list of states. This allows the\r\n<code>include</code> to return a representation of included sls file to\r\nreference states from this sls file.\r\n\r\nIn the same fashion than state, every state that follows an include will\r\nrequire on it to enforce linear execution.\r\n\r\n### Example:\r\n\r\n```python\r\nfrom dawdaw.states import include\r\n\r\ninclude(\"some_state\")\r\ninclude(\"another_state\")\r\n```\r\n\r\n### Reference:\r\n\r\nAn include can be use to reference a state of the included sls file (and it's\r\nrecommand to to avoid global namespaced reference) using the <code>.get</code>\r\nmethod. <code>.get</code> takes 2 parameters: the module and the name.\r\n\r\nExample:\r\n```python\r\nfrom dawdaw.states import include, pkg\r\n\r\nsome_state = include(\"some_state\")\r\ninclude(\"another_state\")\r\n\r\npkg.installed(\"stuff\", require=[some_state.get(\"a_module\", \"a_name\")])\r\n```\r\n\r\n**If the included sls file is not a dawdaw file, you must pass the argument\r\n<code>in_dawdaw=False</code> to include because of namespacing.**\r\n\r\nExample:\r\n```python\r\nfrom dawdaw.states import include, pkg\r\n\r\nsome_state = include(\"some_state\", in_dawdaw=False)\r\n\r\npkg.installed(\"stuff\", watch=[some_state.get(\"a_module\", \"a_name\")])\r\n```\r\n\r\nPillar, grains and opts\r\n-----------------------\r\n\r\nAll those 3 salt artifacts are accessible very easily by simply importing them\r\nand they will behave the same way than they behave in jinja2 templates (hint:\r\nthey are dictionaries):\r\n\r\n```python\r\nfrom dawdaw import pillar, grains, opts\r\n\r\npillar[\"stuff\"]\r\n```\r\n\r\ndebug\r\n-----\r\n\r\nDawdaw comes with a helper <code>debug</code> to debug what it does. This helper will simply print\r\non the shell the generated yaml (you'll see it in the logs or if you run salt\r\nlocally using \"salt-call --local\").\r\n\r\nUsage:\r\n\r\n```python\r\nfrom dawdaw.utils import debug\r\n\r\ndebug()\r\n```\r\n\r\nYou can pass a boolean argument to <code>debug</code> activated/desactivate debugging:\r\n\r\n```python\r\nfrom dawdaw.utils import debug\r\n\r\ndebug()\r\n\r\nif some_stuff:\r\n    # finally don't need to debug\r\n    debug(False)\r\n```\r\n\r\nAlso, since this is full python you can drop in [ipdb](https://github.com/gotcha/ipdb) to just debug your code. **Be sure to only do that if you run salt locally**.\r\n\r\nLicence\r\n-------\r\n\r\nBelgian Beerware.\r\n\r\nFootnotes\r\n---------\r\n\r\nI've had fun writing it, hopes you'll have using it. You don't want to know how it's made.\r\n\r\nÂ¹: I have [another experiment](https://github.com/Psycojoker/cellar) that try\r\nto solve this problem, but I'm not writing enough salt right now to move on\r\nit.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}